#!/bin/bash -e
# co2do.sh
# by hackerb9, February 2026
#
# Given a .CO machine language file for a TRS-80 Model 100 (or similar),
# creates a .DO file containing a BASIC loader which will install the .CO
# to the correct address using POKE and then start it.
#
# USAGE: co2do.sh FOO.CO FOO.DO
#        Transfer FOO.DO to M100.
#        On M100: run "FOO"
#
# Features:
#
# * Inspired by Stephen Adolph's efficient encoding scheme which
#   increases storage size by at most 2x + k (where k is approx. 500),
#   and on average closer to 1.3x + k.
#
# * Works on any of the Kyotronic Sisters: 
#     Kyocera Kyotronic 85, TRS-80 Model 100/102, Tandy 200, 
#     NEC PC-8201A/8300, and Olivetti M10.
#
# * BASIC Automatically CLEARs the correct space and CALLs the program.
#
# * Uses .CO header to detect where to POKE, length mismatch, and CALL addr.
#
# * As a special bonus, if you use the -t option, it will display a
#   Unicode version of the program instead of writing to a .DO file.
#   (Requires the tandy-200.charmap file from hackerb9/tandy-locale.)

# Todo: * Move length check out of BASIC code to save space.
#       * Prevent POKEing to bad parts of RAM.
#         (E.g., POKE Q where Q<HIMEM or Q>=MAXRAM).


function usage() {
    cat <<EOF
Usage: co2do.sh <INPUT.CO> [OUTPUT.DO]
EOF
}

function main() {
    declare -i TOP LEN EXE
    TOP=$1+$2*256
    LEN=$3+$4*256
    EXE=$5+$6*256
    shift 6
    cat<<-EOF >&2
	TOP: $TOP
	END: $((TOP+LEN))
	EXE: $EXE
	EOF
    cat <<-EOF
	10 MAXFILES=0: CLEAR 10, $TOP
	20 DEFINT A-Z
	30 TP=$((TOP-65536)): LN=$LEN: EX=$((EXE-65536))
	40 GOSUB 13000
	50 IF PEEK(1)<>148 THEN CALL EX ELSE EXEC EX
	60 END
	13000 'Decode ML
	13010 CLS:Q=0:H$=CHR\$(13)
	13020 ?"     / $((LEN-1)) $input at $TOP";
	EOF
    emitbasicdecode
    printf "14000 '$input"
    emitdata "$@"
    warnmem $TOP $LEN $EXE $#
    return			# Return result from warnmem
}

function emitdata() {
    local -i linenum=14000 
    local -i v
    for v; do
	if (( count++ % 120 == 0 )); then
	    printf '\n%d DATA"' $((linenum+=10))
	fi
	# Escape quotation mark, slash, delete, and ctrl chars (except tab)
	if (( (v<32 && v!=9) || v==34 || v==23 || v==47 || v==127 )); then
	    v=v+128
	    printf "/"
	fi
	printf -v x "%x" $v
	printf "\x$x"
    done
    # End of DATA marked by '//'
    printf '\n%d DATA"//"\n' $((linenum+=10))
}

function emitbasicdecode() {
    # Credit to Stephen Adolph for the decode routine and encoding scheme.
    # Any errors are mine (hackerb9).
    # Modifications:
    # * autodetect the load address from binary.
    # * use the invalid sequence "//" for End of Data,
    #   which allows me to quote DEL (7F) using "/\xFF".
    # * subtract 128 instead of adding it, just for aesthetics.
    # * double check the filesize matches the header length.
    # * do not discard a quoting "/" at the end of a DATA line.
    cat <<-"EOF"
        13029 '?:?TIME$;CHR$(27);"H";
	13030 READP$:FORX=1TOLEN(P$):a$=MID$(P$,X,1)
	13040 if a$="/" then if e=1 then 13080: else e=1: goto 13070
	13050 v=asc(a$): if e=1 then v=v-128: e=0
	13060 ?H$q;:POKEQ+TP,v:Q=Q+1
	13070 NEXT:GOTO13030
	13081 '?:?time$
	13090 RETURN
	EOF
}


declare -i ERRINVALIDCO=$((1<<0))
declare -i ERRTOPINVALID=$((1<<1))
declare -i ERRTOP8K=$((1<<2))
declare -i ERRTOP8KDO=$((1<<3))
declare -i ERRMAXRAMT200=$((1<<4))
declare -i ERRMAXRAMNEC=$((1<<5))
declare -i ERRMAXRAMKYO=$((1<<6))
#declare -i ERR=$((1<<))
#declare -i ERR=$((1<<))


function warnmem() {
    # Print warnings given TOP, LEN, EXE, and size of the ML program
    local -i top=$1 len=$2 exe=$3 mlsize=$4
    local -i end=top+len  err=0

    # Sanity check
    if ((len != mlsize)); then
	printf "\nERROR:\n\tNot a valid .CO file. LEN=$len, but FILESIZE=$mlsize.\n\n">&2
	err=1^ERRINVALIDCO
    fi

    # due to overhead, this program cannot convert some .CO files to BASIC.
    if ((top<32768)); then
	printf "\nERROR:\n\tTOP ($top) < 32768, writing to Read-only Memory.\n\n" >&2
	err=err^ERRTOPINVALID
    elif ((top<59555)); then
	printf "Warning:\n\tTOP ($top) is very low. $output may not work on 8K machines.\n\n" >&2
	err=err^ERRTOP8K
    elif ((top<61000)); then
	cat <<-EOF >&2
	Note: TOP ($top) is too low for 8K machines to fit both .DO and .BA.
	To workaround, tokenize directly from a device instead of downloading.
	For example, RUN "COM:98N1" or RUN "0:$output"

	EOF
	err=err^ERRTOP8KDO
    fi

    # Check if END exceeds MAXRAM
    if ((end>61104)); then
	printf "\nWarning:\n\tEND ($end) > 61104. $input will crash a Tandy 200!\n\n">&2
	err=err^ERRMAXRAMT200
    elif ((end>62336)); then
	printf "\nWarning:\n\tEND ($end) > 62336. $input will crash PC-8201/8300 and Tandy 200\n\n">&2
	err=err^ERRMAXRAMNEC
    elif ((end>62960)); then
	printf "\nError:\n\tEND ($end) > 62960. $input will crash *all* Model-T computers!!\n\n">&2
	err=err^ERRMAXRAMKYO
    fi

    return $err
}


{
    # CLI args
    tandycharset=cat
    if [[ "$1" == "-t" ]]; then
	shift
	tandycharset="iconv -f $(dirname $0)/tandy-200.charmap"
    fi
    if [[ "$1" == "-" ]]; then shift; set -- /dev/stdin "$@"; fi

    if [ -z "$1" ]; then
	usage
	exit 1
    elif [ ! -r "$1" ]; then
	echo "'$1' is not readable"
	exit 1
    else
	input="$1"
	shift
    fi

    output=/dev/stdout
    if [ "$1" ]; then
	output="$1"
	shift
    elif [[ $tandycharset == "cat" ]]; then
	if [[ $input == *.CO ]]; then
	    output=${input%.CO}.DO
	elif [[ $input == *.co ]]; then
	    output=${input%.co}.do
	fi
    fi
}

outputfilter() {
    # Add carriage returns since NEC PC-8201 uses Mac (or DOS?) line endings.
    # Append ^Z at end of file to signal receiving M100 that file is finished.
    sed 's/$/\r/g'
    printf '\x1A'
}


main $(od -t u1 -v -An "$input") | $tandycharset | outputfilter > "$output"
err=${PIPESTATUS[0]}

if [[ $tandycharset == "cat" ]]; then
    if (( err & ERRTOP8KDO )); then
	cat <<-EOF
	Use a serial connection to transfer $output to your Model-T
	by using this BASIC command (pick the one for your machine):
	    run "COM:88N1"	# Model 100, Tandy 102, Kyotronic 85, Olivetti M10
	    run "COM:88N1ENN"	# Tandy 200
	    run "COM:8N81XN" 	# NEC PC-8201/8300
	On your host PC, send the file to serial port. For example:
	    cat $output >/dev/ttyUSB0
	EOF
    elif (( !err )); then
	outnodo=${output##*/}
	outnodo=${outnodo%.[Dd][Oo]}
	cat <<-EOF
	Now transfer $output to your Model-T
	and in BASIC type
	    run "$outnodo"
	EOF
    fi
fi
exit $err
